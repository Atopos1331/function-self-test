<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

<head>
  <title>COMP 1023 Self-test Web Page</title>
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
  <meta name="keywords" content="" />
  <!--link rel="stylesheet" href="img/Underground.css" type="text/css" /-->
  <!-- Bubble tooltips: adopted from: http://www.web-graphics.com/mtarchive/BubbleTooltips.html-->
  <!-- For automatic tooltip: -->
  <script src="bubbletooltips/bubbletooltips.js" type=text/javascript></script>
  <!-- Example:  usage <a href="" title=""></a>  -->
  <!-- For customize tooltip -->
  <link media=all href="bubbletooltips/bt.css" type=text/css rel=stylesheet>
  <script type="text/javascript" src="jquery/jquery.js"></script>

  <!-- JQuery Calender is located here... -->
  <style type="text/css">
    @import url(jquerycalendar/jquery-calendar.css);
  </style>
  <script type="text/javascript" src="jquerycalendar/jquery-calendar.js"></script>

  <script type="text/javascript" src="selftestmenu.js"></script>
  <link rel="stylesheet" type="text/css" href="selfteststyle.css" />
  <!-- highslide stuff: TESTING... -->
  <script type="text/javascript" src="highslide/highslide-with-html.js"></script>
  <script type="text/javascript">
    hs.graphicsDir = 'highslide/graphics/';
    hs.outlineType = 'rounded-white';
    hs.outlineWhileAnimating = true;
  </script>
  <style type="text/css">
    @import url(highslide/myslide.css);
  </style>
  <!-- END OF highslide stuff -->

</head>

<!-- Start of the main html body -->

<body>

  <!-- wrap starts here -->
  <div id="main">
    <div id="wrap">
      <!-- header -->
      <div id="header">
        <span id="slogan"></span>
        <!-- tabs -->
        <ul>
          <li class="showall-solution"><a href="#" title="Show all solutions"><span>Show all solutions</span></a></li>
          <li class="hideall-solution"><a href="#" title="Hide all solutions"><span>Hide all solutions</span></a></li>


          <li id="tabShowNormalView"><a href="#" title="The normal webpage view"><span>Web view</span></a></li>
          <li id="tabShowAllOnePage"><a href="#" title="The view which is suitable for printing"><span>Printable
                view</span></a></li>
          <li id="tabIncFontSize"><a href="#" title="Increase the font size"><span>++ Font size</span></a></li>
          <li id="tabDecFontSize"><a href="#" title="Decrease the font size"><span>-- Font size</span></a></li>


        </ul>
      </div>

      <div id='block1' style="display:block;	clear:left;">
        <h1>Self-test 7: Functions<br /> </h1>

        <ol>
          <li>
            <div class="question-wrapper" style="position: static;">
              <div class="question-content">
                <p><b>[easy]</b> Which of the following practices improve code readability and adherence to coding
                  standards in Python functions? (more than one correct answers)</p>
                <ol type="A">
                  <li>Adding type hints for parameters (e.g., def add(a: int, b: int))</li>
                  <li>Specifying return types (e.g., def add(a: int, b: int) -> int)</li>
                  <li>Including a docstring (triple quotes) at the start of a function to explain its purpose</li>
                  <li>Using single-letter variable names (e.g., def f(x, y): return x + y)</li>
                </ol>
              </div>

              <div class="toggle-solution">Solution</div>
              <div class="solution-content">
                <b>A, B, C</b><br>
                Explanation:
                <ul>
                  <li><b>A.</b> Type hints clarify the expected data types of parameters, making it easier for other
                    developers (or future you) to understand how to use the function.</li>
                  <li><b>B.</b> Explicit return type annotations (e.g., -> int) communicate what the function outputs,
                    reducing ambiguity.</li>
                  <li><b>C.</b> Docstrings (enclosed in """) document a function's purpose, parameters, return values,
                    and edge cases - critical for maintainability.</li>
                  <li><b>D.</b> incorrect: Single-letter variable names (like x, y, f) are vague and make code harder to
                    read. Descriptive names (e.g., def add(num1: int, num2: int)) are better.</li>
                </ul>
                Take-away:
                <ul>
                  <li>A readable code could not only let others understand your code, but also helps yourself!</li>
                  <li>If you are lazy to keep the code readble, you may go crazy after seeing the code you wrote one
                    year ago.</li>
                </ul>
              </div>
            </div>
            <hr>
          </li>

          <li>
            <div class="question-wrapper" style="position: static;">
              <div class="question-content">
                <p><b>[easy]</b> What is the correct order for parameters in a function definition?</p>
                <ol type="A">
                  <li>Default parameters first, then non-default parameters</li>
                  <li>Non-default parameters first, then default parameters</li>
                  <li>No order required</li>
                  <li>Keyword parameters first, then positional parameters</li>
                </ol>
              </div>

              <div class="toggle-solution">Solution</div>
              <div class="solution-content">
                <b>B. Non-default parameters first, then default parameters</b><br>
                Explanation:
                <ul>
                  <li>In Python, non-default parameters must come before default parameters in function definitions.
                  </li>
                  <li>This rule prevents ambiguity in function calls and ensures clear parameter binding.</li>
                  <li>Think you have a function: def func(a=3, b=2, c), then func(1, 3) could be intepreted
                    as both a=1, c=3 (b=2 by default) or b=1, c=3 (a=3 by default), which is ambiguous</li>
                </ul>
              </div>
            </div>
            <hr>
          </li>

          <li>
            <div class="question-wrapper" style="position: static;">
              <div class="question-content">
                <p><b>[easy]</b> What is the output of the following code?</p>
                <pre>def swap1(a, b): c = a; a = b; b = c
def swap2(pair): c = pair[0]; pair[0] = pair[1]; pair[1] = c

a, b = 114, 514

swap1(a, b)
print(a, b)

pair = [a, b]
swap2(pair)
print(a, b)
print(*pair)</pre>
                <ol type="A">
                  <li>114 514 &lt;new line&gt; 114 514 &lt;new line&gt; 114 114</li>
                  <li>114 514 &lt;new line&gt; 114 514 &lt;new line&gt; 514 114</li>
                  <li>114 514 &lt;new line&gt; 514 114 &lt;new line&gt; 514 114</li>
                  <li>114 514 &lt;new line&gt; 514 114 &lt;new line&gt; 114 514</li>
                </ol>
              </div>

              <div class="toggle-solution">Solution</div>
              <div class="solution-content">
                <b>B. 114 514 &lt;new line&gt; 114 514 &lt;new line&gt; 514 114</b><br>
                Explanation:
                <ul>
                  <li><b>swap1(a, b):</b> Integers are passed by value. Local changes don't affect original variables.
                  </li>
                  <li><b>swap2(pair):</b> Lists are passed by reference. Changes to list elements affect the original
                    list.</li>
                  <li>After swap1: a, b remain 114, 514</li>
                  <li>After swap2: pair becomes [514, 114], but a, b are still 114, 514</li>
                </ul>
                Take-away:
                <ul>
                  <li>Understanding mutable vs immutable objects is crucial.</li>
                  <li>A common bug for beginners is expecting primitive types to be modified by functions.</li>
                </ul>
              </div>
            </div>
            <hr>
          </li>

          <li>
            <div class="question-wrapper" style="position: static;">
              <div class="question-content">
                <p><b>[easy]</b> What is the value returned by this function?</p>
                <pre>def func():
    result = 0
    for i in range(100): result += i</pre>
                <ol type="A">
                  <li>4950</li>
                  <li>None</li>
                  <li>5050</li>
                  <li>0</li>
                </ol>
              </div>

              <div class="toggle-solution">Solution</div>
              <div class="solution-content">
                <b>B. None</b><br>
                Explanation:
                <ul>
                  <li>The function doesn't have an explicit return statement, so it returns None by default.</li>
                  <li>The result variable is calculated but never returned.</li>
                </ul>
                Take-away:
                <ul>
                  <li>Always remember to return values from functions. Missing return statements are a common source of
                    bugs.</li>
                </ul>
              </div>
            </div>
            <hr>
          </li>

          <li>
            <div class="question-wrapper" style="position: static;">
              <div class="question-content">
                <p><b>[easy]</b> Identify the error in the following code that uses mixed positional and keyword
                  arguments:</p>
                <pre>def calculate(a, b, c):  
    return a + b * c  

print(calculate(2, c=3, 4))</pre>
                <ol type="A">
                  <li>c=3 is an invalid keyword argument</li>
                  <li>Positional argument 4 follows a keyword argument c=3</li>
                  <li>The function is missing a return statement</li>
                  <li>a, b, and c are not defined</li>
                </ol>
              </div>

              <div class="toggle-solution">Solution</div>
              <div class="solution-content">
                <b>B. Positional argument 4 follows a keyword argument c=3</b><br>
                Explanation:
                <ul>
                  <li>Once you use a keyword argument, all subsequent arguments must also be keyword arguments.</li>
                </ul>
              </div>
            </div>
            <hr>
          </li>

          <li>
            <div class="question-wrapper" style="position: static;">
              <div class="question-content">
                <p><b>[easy]</b> What is the output of running test.py directly (not importing it), where test.py
                  contains:</p>
                <pre>print("Outside main")  
if __name__ == "__main__":  
    print("Inside main")</pre>
                <ol type="A">
                  <li>Only "Outside main"</li>
                  <li>Only "Inside main"</li>
                  <li>Both "Outside main" and "Inside main"</li>
                  <li>No output</li>
                </ol>
              </div>

              <div class="toggle-solution">Solution</div>
              <div class="solution-content">
                <b>C. Both "Outside main" and "Inside main"</b><br>
                Explanation:
                <ul>
                  <li>When running a script directly, __name__ equals "__main__", so both print statements execute.</li>
                </ul>
                Take-away:
                <ul>
                  <li>put testing codes of the module functions under 'if __name__ == "__main__"'.</li>
                </ul>
              </div>
            </div>
            <hr>
          </li>

          <li>
            <div class="question-wrapper" style="position: static;">
              <div class="question-content">
                <p><b>[easy]</b> If you have a package shapes with a module circle.py containing a function area(),
                  which statement imports area() correctly?</p>
                <ol type="A">
                  <li>from shapes.circle import area</li>
                  <li>import shapes.area</li>
                  <li>from shapes import circle.area</li>
                  <li>import circle.area from shapes</li>
                </ol>
              </div>

              <div class="toggle-solution">Solution</div>
              <div class="solution-content">
                <b>A. from shapes.circle import area</b><br>
                Explanation:
                <ul>
                  <li>This imports the area function directly from the circle module in the shapes package.</li>
                </ul>
              </div>
            </div>
            <hr>
          </li>

          <li>
            <div class="question-wrapper" style="position: static;">
              <div class="question-content">
                <p><b>[medium]</b> Which of the following correctly uses *args to accept variable positional arguments?
                </p>
                <p>A.</p>
                <pre>def sum_all(*args):  
    return sum(args)  
print(sum_all(1, 2, 3, 4))</pre>
                <p>B.</p>
                <pre>def sum_all(args*):  
    return sum(args)  
print(sum_all(1, 2, 3, 4))</pre>
                <p>C.</p>
                <pre>def sum_all(**args):  
    return sum(args)  
print(sum_all(1, 2, 3, 4))</pre>
                <p>D.</p>
                <pre>def sum_all(args):  
    return sum(args)  
print(sum_all(1, 2, 3, 4))</pre>
              </div>

              <div class="toggle-solution">Solution</div>
              <div class="solution-content">
                <b>A</b><br>
                Explanation:
                <ul>
                  <li>*args collects variable positional arguments into a tuple.</li>
                </ul>
                Take-away:
                <ul>
                  <li>*args for variable positional arguments</li>
                  <li>**kwargs for variable keyword arguments</li>
                  <li>Useful for flexible function interfaces</li>
                </ul>
              </div>
            </div>
            <hr>
          </li>

          <li>
            <div class="question-wrapper" style="position: static;">
              <div class="question-content">
                <p><b>[medium]</b> Can the code snippet below run without error? If yes, what will be the output?</p>
                <pre>def foo(*args, **kwargs):
    s = f'I got {sum(args)} candies, {kwargs["haha"]} haha and {kwargs["hehe"]} hehe.'
    print(s)
foo(5, 4, 3, haha=2, hehe=1)</pre>
              </div>

              <div class="toggle-solution">Solution</div>
              <div class="solution-content">
                <b>Yes, and the output is: I got 12 candies, 2 haha and 1 hehe.</b>
              </div>
            </div>
            <hr>
          </li>

          <li>
            <div class="question-wrapper" style="position: static;">
              <div class="question-content">
                <p><b>[medium]</b> Can the code snippet below run without error? If yes, what will be the output?</p>
                <pre>def foo(*args):
    for item in args:
        item += item
l, s = ['COMP1023'], 'Python'
foo(l, s)
print(l, s)</pre>
              </div>

              <div class="toggle-solution">Solution</div>
              <div class="solution-content">
                <b>Yes, and the output is: ['COMP1023', 'COMP1023'] Python</b><br>
                Note that string object is also immutable as parameters.
              </div>
            </div>
            <hr>
          </li>

          <li>
            <div class="question-wrapper" style="position: static;">
              <div class="question-content">
                <p><b>[medium]</b> Which of the following is a valid lambda function to add two numbers?</p>
                <ol type="A">
                  <li>add(x, y) = lambda: x + y</li>
                  <li>def add(x, y): return x + y</li>
                  <li>add = lambda x, y: x + y</li>
                  <li>add = lambda x, y: return x + y</li>
                </ol>
              </div>

              <div class="toggle-solution">Solution</div>
              <div class="solution-content">
                <b>C. add = lambda x, y: x + y</b>
              </div>
            </div>
            <hr>
          </li>

          <li>
            <div class="question-wrapper" style="position: static;">
              <div class="question-content">
                <p><b>[medium]</b> Find the correct option to fill the blank in the program</p>
                <pre># input: 1 2 3 4 5 (seperated by spaces, not new line)

nums = __________
print(nums) # output: [1, 2, 3, 4, 5]</pre>
                <ol type="A">
                  <li>[ int(input()) for _ in range(5) ]</li>
                  <li>map(int, input())</li>
                  <li>input().split()</li>
                  <li>list(map(int, input().split()))</li>
                </ol>
              </div>

              <div class="toggle-solution">Solution</div>
              <div class="solution-content">
                <b>D. list(map(int, input().split()))</b><br>
                Explanation:
                <ul>
                  <li>input().split() creates ['1', '2', '3', '4', '5']</li>
                  <li>map(int, &lt;some list&gt;) converts all element in the list to integers</li>
                  <li>list() converts the map object to a list</li>
                  <li>option A is incorrect because call input() once would directly read the whole line</li>
                </ul>
              </div>
            </div>
            <hr>
          </li>

          <li>
            <div class="question-wrapper" style="position: static;">
              <div class="question-content">
                <p><b>[medium]</b> What code should be put in the blank in the following code to output all multiples of
                  7 in the range [0, 999]?</p>
                <pre>result = filter(____, range(1000))</pre>
                <ol type="A">
                  <li>x // 7 == 0</li>
                  <li>lambda x: x % 7 == 0</li>
                  <li>x % 7 == 0</li>
                  <li>lambda x: x % 7</li>
                </ol>
              </div>

              <div class="toggle-solution">Solution</div>
              <div class="solution-content">
                <b>B. lambda x: x % 7 == 0</b><br>
                Explanation:
                <ul>
                  <li>filter() needs a function that returns True/False. The lambda checks if a number is divisible by
                    7.</li>
                </ul>
              </div>
            </div>
            <hr>
          </li>

          <li>
            <div class="question-wrapper" style="position: static;">
              <div class="question-content">
                <p><b>[medium]</b> Alice has the above program:</p>
                <pre>def func1(): ...
def func2(): ...
...
def func8(): ...

print('enter 1 ~ 8 to use the correspond function!')
target = input()
match target:
    case '1': func1()
    case '2': func2()
    ...
    case '8': func8()
    case _: print('invalid!')</pre>
                <p>But she thinks writing 8 case clauses is too tiring! Can you help her think about a easier way to
                  replace the match-case code block with one line of code?</p>
              </div>

              <div class="toggle-solution">Solution</div>
              <div class="solution-content">
                <b>Answer:</b><br>
                <ul>
                  <li><b>method 1:</b> <pre>{ '1': func1, '2': func2, '3': func3, ..., '8': func8 }.get(target, lambda: print('Invalid!'))()</pre></li>
                  <li><b>method 2 (unsafe):</b> <pre>eval(f"func{target}()") if '1' &lt;= target &lt;= '8' else print('Invalid!')</pre></li>
                </ul>
                <b>Why Method 2 is Unsafe:</b>
                <ul>
                  <li><b>1. Input Validation Issues</b>
                    <ul>
                      <li>If the user inputs non-numeric strings (e.g., 'abc'), the condition '1' &lt;= target &lt;= '8'
                        may behave unexpectedly</li>
                      <li>The program could crash or produce undefined behavior</li>
                    </ul>
                  </li>
                  <li><b>2. Code Injection Vulnerability</b>
                    <ul>
                      <li>The eval() function executes arbitrary Python code, making it extremely dangerous</li>
                      <li>Attack Example: Try inputting <pre>1() or print(__import__('os').listdir()) #</pre> (the whole string
                        from '1' to '#')</li>
                      <li>This malicious input will run the python code below: <pre>func1() or print(__import__('os').listdir()) #()</pre></li>
                      <li>which executes the function AND lists all files in the current directory</li>
                      <li>In a server environment, attackers could potentially read, modify, or delete critical files
                      </li>
                    </ul>
                  </li>
                </ul>
                Take-away:
                <ul>
                  <li>Dictionary-based function dispatch provides clean, efficient code while maintaining security. The
                    eval() function should be avoided with user input due to serious security vulnerabilities that can
                    lead to code injection attacks.</li>
                </ul>
              </div>
            </div>
            <hr>
          </li>

          <li>
            <div class="question-wrapper" style="position: static;">
              <div class="question-content">
                <p><b>[hard]</b> What is the output of the following code?</p>
                <pre>def func(array = [0]):
    array[0] += 1
    print(array[0], end=' ')

for _ in range(5): func()</pre>
                <ol type="A">
                  <li>0 0 0 0 0</li>
                  <li>0 1 2 3 4</li>
                  <li>1 2 3 4 5</li>
                  <li>There is a syntax error</li>
                </ol>
              </div>

              <div class="toggle-solution">Solution</div>
              <div class="solution-content">
                <b>C. 1 2 3 4 5</b><br>
                Explanation:
                <ul>
                  <li>Mutable default arguments are shared between function calls. The same list [0] is reused each
                    time.</li>
                </ul>
                Take-away:
                <ul>
                  <li>Use None as default and create new objects inside the function:</li>
                </ul>
                <pre>def func(array=None):
    if array is None:
        array = [0]
    # rest of function</pre>
              </div>
            </div>
            <hr>
          </li>

          <li>
            <div class="question-wrapper" style="position: static;">
              <div class="question-content">
                <p><b>[hard]</b> What problem occurs for the following modules?</p>
                <p>user_management.py</p>
                <pre>from user_validation import is_valid_age

def create_user(name: str, age: int) -> dict:
    """create a user, but check is the age valid before creation"""
    if is_valid_age(age): 
        return {"name": name, "age": age, "status": "valid"}  
    else:  
        return {"name": name, "age": age, "status": "invalid"}  

def get_min_age() -> int:  
    """return the minimum age that is valid"""  
    return 18</pre>
                <p>user_validation.py</p>
                <pre>from user_management import get_min_age

def is_valid_age(age: int) -> bool:  
    """check is the age valid"""  
    min_age = get_min_age()
    return age >= min_age  

def validate_user(user: dict) -> str:  
    """return is a user valid"""  
    if user["status"] == "valid":  
        return f"User {user['name']} is valid"  
    else:  
        return f"User {user['name']} is invalid (age too low)"</pre>
                <ol type="A">
                  <li>An import error would be caused because the two module imports each other</li>
                  <li>Since the two imported functions do not call each other, they could be successfully imported
                    without error.</li>
                  <li>The modules overwrite each other's functions</li>
                  <li>No error, Python could handle circular imports automatically</li>
                </ol>
              </div>

              <div class="toggle-solution">Solution</div>
              <div class="solution-content">
                <b>A. An import error would be caused because the two modules import each other</b><br>
                Explanation:
                <ul>
                  <li>Circular imports create dependency loops that Python cannot resolve.</li>
                </ul>
              </div>
            </div>
            <hr>
          </li>

          <li>
            <div class="question-wrapper" style="position: static;">
              <div class="question-content">
                <p><b>[hard]</b> What is the correct way to solve the problem in the last question? (more than one
                  option is correct)</p>
                <ol type="A">
                  <li>Move the get_min_age() function to a third module (e.g., config.py) and import it into both
                    user_management.py and user_validation.py.</li>
                  <li>Move the import statement inside the functions that require them (e.g., move "from user_management
                    import get_min_age" inside is_valid_age()).</li>
                  <li>Move all functions in these two modules into a single new module (e.g. user_functions.py)</li>
                  <li>No action need to take because no errors are occured in the last question</li>
                </ol>
              </div>

              <div class="toggle-solution">Solution</div>
              <div class="solution-content">
                <b>A, B, C are all correct</b><br>
                Take-away:
                <ul>
                  <li><b>Option A:</b> Best practice - create shared modules for common dependencies</li>
                  <li><b>Option B:</b> Lazy imports - import only when needed</li>
                  <li><b>Option C:</b> Sometimes appropriate for closely related functions</li>
                  <li>Design modules with clear hierarchies to avoid circular dependencies</li>
                </ul>
              </div>
            </div>
            <hr>
          </li>

          <li>
            <div class="question-wrapper" style="position: static;">
              <div class="question-content">
                <p><b>[hard]</b> Complete the following program:</p>
                <pre>from functools import reduce

scientists = [
    {'name': 'Alan Turing', 'age': 105, 'gender': 'male'},
    {'name': 'Dennis Ritchie', 'age': 76, 'gender': 'male'},
    {'name': 'Ada Lovelace', 'age': 202, 'gender': 'female'},
    {'name': 'Frances E. Allen', 'age': 84, 'gender': 'female'}
]

def group_by_gender(accumulator, value):

    ################ write one line of code here ################

    return accumulator

grouped = reduce(group_by_gender, scientists, {'male': [], 'female': []})
print(grouped)</pre>
                <p>output:</p>
                <pre>{'male': ['Alan Turing', 'Dennis Ritchie'], 'female': ['Ada Lovelace', 'Frances E. Allen']}</pre>
              </div>

              <div class="toggle-solution">Solution</div>
              <div class="solution-content">
                <b>Answer:</b><br>
                <pre>accumulator[value['gender']].append(value['name'])</pre>
              </div>
            </div>
            <hr>
          </li>

          <li>
            <div class="question-wrapper" style="position: static;">
              <div class="question-content">
                <p><b>[hard]</b> Design a function myprint() that behaves like the built-in print() function but with a
                  call counter</p>
                <p><b>Task:</b> Create a function myprint() that:</p>
                <ol>
                  <li>Accepts the same arguments as the built-in print() function (*args, **kwargs)</li>
                  <li>Before each output, prints the number of times it has been called previously</li>
                  <li>Then prints the intended output normally</li>
                </ol>
                <p><b>Example:</b></p>
                <pre>myprint("Hello, World!")
myprint(10, 20, 30, sep=" + ")
myprint("Python", "is", "fun", sep=" ", end="!\n")  
myprint()</pre>
                <p><b>Expected Output:</b></p>
                <pre>0
Hello, World!
1
10 + 20 + 30
2
Python is fun!
3
</pre>
                <p><b>Explanation:</b></p>
                <ul>
                  <li>First call: prints 0 (called 0 times before), then Hello, World!</li>
                  <li>Second call: prints 1 (called 1 time before), then 10 + 20 + 30</li>
                  <li>Third call: prints 2 (called 2 times before), then Python is fun!</li>
                  <li>Fourth call: prints 3 (called 3 times before), then empty line</li>
                </ul>
                <p><b>Hint:</b> You don't need to reimplement print(). Just "wrap" the existing print() function and add
                  counter functionality.</p>
              </div>

              <div class="toggle-solution">Solution</div>
              <div class="solution-content">
                <b>Answer:</b><br>
                <pre>counter = 0

def myprint(*args, **kwargs):
    global counter
    print(counter)
    print(*args, **kwargs)
    counter += 1</pre>
                Take-away:
                <ul>
                  <li>This pattern of "wrapping" existing functions to add functionality is fundamental to decorators
                    and aspect-oriented programming. It's commonly used for logging, timing, authentication, and other
                    cross-cutting concerns.</li>
                </ul>
              </div>
            </div>
            <hr>
          </li>

          <li>
            <div class="question-wrapper" style="position: static;">
              <div class="question-content">
                <p><b>[insane/broadening]</b> Higher-Order Functions and Decorators</p>
                <p>Functions can work on other functions or return functions as results. This is called "higher-order
                  functions". Let's explore three levels:</p>

                <p><b>Level 1: Functions that work ON functions</b></p>
                <p>Write a function that takes another function and evaluates it over a range of values.</p>
                <p>Example:</p>
                <pre>def function_values_lister(func, start, end):
    return [func(i) for i in range(start, end + 1)]

# Usage:
def square(x): return x ** 2
print(function_values_lister(square, 1, 5))  # Output: [1, 4, 9, 16, 25]</pre>

                <p><b>Level 2: Functions that RETURN functions</b></p>
                <p>Write a function factory that creates power functions.</p>
                <p>Example:</p>
                <pre>def power_function_generator(n):
    def power(x):
        return x ** n
    return power

# Usage:
square = power_function_generator(2)
cube = power_function_generator(3)
print(square(3), cube(3))  # Output: 9, 27</pre>

                <p><b>Level 3: Functions that work ON functions AND RETURN functions (Decorators)</b></p>
                <p>Create a decorator that adds a call counter to any function. (same logic as the last problem)</p>

                <p>Example:</p>
                <pre>counter_for_functions = {}

def add_counter(target_function):
    # when add_counter() is called, all the 'target_function' below will be replaced with the function you passed
    counter_for_functions[target_function] = 0
    
    def wrapper(*args, **kwargs): 
        # use a function to wrap the target_function with some new features, just like "myprint" in the last question
        print(counter_for_functions[target_function])
        result = target_function(*args, **kwargs)
        counter_for_functions[target_function] += 1
        return result
    
    return wrapper

# Usage:
myprint = add_counter(print) 
# It's like renaming the function wrapped(*arg, **kwargs) to 'myprint', where 'target_function' in the original function is replaced with 'print'

myprint('hello!')  # Output: 0\n hello!
myprint('world!')  # Output: 1\n world!</pre>

                <p><b>Decorator Syntax:</b></p>
                <p>Python provides special syntax for decorators:</p>
                <pre>@add_counter
def greet(): 
    print('hello')

# This is equivalent to:
def greet(): 
    print('hello')
greet = add_counter(greet)</pre>

                <p><b>Your Task:</b></p>
                <p>Create a @timer decorator that measures and prints how long a function takes to execute.</p>

                <p>Requirements:</p>
                <ul>
                  <li>Use time.time() from the time module</li>
                  <li>Print execution time in format: "Time consumed: X.XXs"</li>
                  <li>Return the original function's result</li>
                </ul>

                <p>Example usage:</p>
                <pre>@timer
def slow_function():
    total = 0
    for i in range(100000000):
        total += i
    return total

result = slow_function()  # Should print: "Time consumed: 2.34s"</pre>

                <p><b>Bonus Question:</b></p>
                <p>List 3 other practical uses for decorators in real programming.</p>
              </div>

              <div class="toggle-solution">Solution</div>
              <div class="solution-content">
                <b>Answer:</b><br>
                <pre>import time

def timer(target_function):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = target_function(*args, **kwargs)
        end_time = time.time()
        elapsed = end_time - start_time
        print(f"Time consumed: {elapsed:.2f}s")
        return result
    return wrapper</pre>

                <b>Other practical decorator uses:</b>
                <ul>
                  <li><b>Logging</b> - Record function calls and parameters for debugging</li>
                  <li><b>Authentication</b> - Check user permissions before executing sensitive functions</li>
                  <li><b>Caching/Memoization</b> - Store results of expensive computations to avoid recalculation</li>
                  <li><b>Rate Limiting</b> - Control how frequently functions can be called</li>
                  <li><b>Input Validation</b> - Verify function arguments meet requirements</li>
                  <li><b>Retry Logic</b> - Automatically retry operations that might fail</li>
                </ul>

                Take-away:
                <ul>
                  <li>Decorators enable clean separation of concerns - you can add cross-cutting functionality (timing,
                    logging, security) without cluttering your core business logic. They're essential for writing
                    maintainable, enterprise-level Python code.</li>
                </ul>
              </div>
            </div>
            <hr>
          </li>
        </ol>
      </div>

      <!-- wrap ends here; don't delete this /div -->
    </div>
</body>
</html>
